require "view/view"require "common/PathCheck"require "common/Constant"require "view/Stage/CharacterManager"require "common/SkillHurt"require "view/Buff/Buff"require "view/Stage/BigHpView"require "common/ColorManager"CBaseCharacter = class( view, function( self, _nType )    if( _nType == nil ) then        error( "CBaseCharacter _nType == nil" )        return    end    self.m_nType = _nType --人物／npcend)--每个继承此类的必须 init一次--function CBaseCharacter.init( self, _nID , _szName, _nMaxHP, _nMaxSP, _nHP, _nSP, _fx, _fy, _movieClipID )function CBaseCharacter.init( self, _nID , _szName, _nMaxHP, _nHP, _nMaxSP, _nSP, _fx, _fy, _skinID )    self.m_lpContainer = CContainer :create() --总层    self.m_lpShadowContainer = CContainer :create() --影子层    self.m_lpCharacterContainer = CContainer :create() --人物层    self.m_lpMovieClipContainer = CContainer :create() --人物MC层    self.m_lpNameContainer = CContainer :create() --名字层    self.m_lpHurtStringContainer = CContainer :create() --名字层    self.m_lpHpContainer = CContainer :create() --血条    self.m_lpEffectContainer = CContainer : create() --特效层    self.m_lpContainer : setControlName( "this is CBaseCharacter self.m_lpContainer 27  " )    self.m_lpShadowContainer : setControlName( "this is CBaseCharacter self.m_lpShadowContainer 28  " )    self.m_lpCharacterContainer : setControlName( "this is CBaseCharacter self.m_lpCharacterContainer 29  " )    self.m_lpMovieClipContainer : setControlName( "this is CBaseCharacter self.m_lpMovieClipContainer 32  ")    self.m_lpNameContainer : setControlName( "this is CBaseCharacter self.m_lpNameContainer 30  " )    self.m_lpHurtStringContainer : setControlName( "this is CBaseCharacter self.m_lpHurtStringContainer 31  " )    self.m_lpHpContainer : setControlName( "this is CBaseCharacter self.m_lpHpContainer 33  " )    self.m_lpEffectContainer : setControlName( "this is CBaseCharacter self.m_lpEffectContainer 34  " )    self.m_lpContainer : addChild( self.m_lpShadowContainer )    self.m_lpContainer : addChild( self.m_lpCharacterContainer )    --self.m_lpContainer : addChild( self.m_lpNameContainer )    -- self.m_lpContainer : addChild( self.m_lpHurtStringContainer )    -- self.m_lpContainer : addChild( self.m_lpHpContainer )    self.m_lpCharacterContainer : addChild( self.m_lpMovieClipContainer )    self.m_lpCharacterContainer : addChild( self.m_lpNameContainer )    self.m_lpCharacterContainer : addChild( self.m_lpHpContainer )    self.m_lpCharacterContainer : addChild( self.m_lpHurtStringContainer )    self.m_lpCharacterContainer : addChild( self.m_lpEffectContainer )    --self.m_lpHurtStringList = {}    self : loadMovieClip( _skinID )    --位置    self.m_nLocationX = _fx or 0 --左右    self.m_nLocationY = _fy or 0 --远近    self.m_nLocationZ = 0 --高    self : setPos()    self.m_nID = _nID --ID    self : setName( _szName )    self.m_nMaxHP = _nMaxHP or 0    self.m_nMaxSP = _nMaxSP or 0    print("self.m_nHP",self.m_nHP,self.m_nMaxHP)    self.m_nHP = _nHP or 0    self.m_nSP = _nSP or 0    self.m_SkinId = _skinID -- 皮肤    self.m_lpStage = nil --场景    self.m_fMoveCallBackTime = _G.Constant.CONST_INIT_MOVE_CALL_BACK_TIME --移动回调时间    local localX = self : getLocationX()    local localY = self : getLocationY()    self.m_lpMoveCallBackPos = ccp( localX, localY )--上一次移动回调时人物位置    self.m_lpNpcCollisionCallBackPos = ccp( localX, localY )--上一次NPC碰撞回调时人物位置    self.m_lpZOrderCallBackPos = ccp( localX, localY )    self.m_lpScheduleMoveHandle = -1 --移动回调句柄    self.m_lpScheduleNpcCollisionHandle = -1 --NPC碰撞回调句柄    self.m_lpScheduleZOrderHandle = -1 --设置Z深度句柄    self.m_nStatus = Constant.CONST_BATTLE_STATUS_IDLE  --初始状态    self.m_buff = {}        --buff列表    self.m_nSkillDuration = 0    self.m_nSkillID = 0             --当前技能ID    self.m_nNextSkillID = 0         --下次连技ID    self.m_nNextSkillID2 = 0         --下下次连技ID    self : setStatus( _G.Constant.CONST_BATTLE_STATUS_IDLE )    --碰撞机配置    self : setColliderXml( _G.Constant.CONST_BATTLE_STATUS_IDLE, self.m_SkinId)    --人物边界值  用于判断越过地图    self.m_nBorder = 0    self : setBorder()    --技能相关配置    self.m_nAttackSkillId1 = 101    self.m_nAttackSkillId2 = 102    self.m_nAttackSkillId3 = 103    self.m_nJumpAttackSkillId = 104    self.m_nSkill1 = 103    self.m_nSkill2 = 0    self.m_nSkill3 = 0    self.m_nSkill4 = 0    self.m_nSkill5 = 0    self.m_nSkill6 = 0    self.m_SkillCDTab = {}    self.m_lpMovePos = nil --移动点    self.m_fXSpeed = nil    self.m_fYSpeed = nil    self.m_nScaleX = 1 --反转值    self : setShadow( "Shadow.png" )    self.m_isFirstEnter = true    --重力    self.m_nCurrentAcceleration = _G.Constant.CONST_BATTLE_JUMP_ACCELERATION    self.m_lpHpSlider = nil --血量条    self.m_lpBigHp = nil --大血条    self.m_nMoveSpeedX = 500    self.m_nMoveSpeedY = 300    self.m_nTenacity = 0 --当前韧性值    -- self.m_nMaxTenacity = 0 --最大韧性值    _G.Config:load( "config/battle_speed.xml" )    local node = _G.Config.battle_speeds : selectSingleNode( "battle_speed[@id="..tostring( self.m_SkinId ).."]")    if not node:isEmpty() then        if node:getAttribute("speed_x") ~= nil then            self.m_nMoveSpeedX = tonumber(node:getAttribute("speed_x"))        end        if node:getAttribute("speed_y") ~= nil then            self.m_nMoveSpeedY = tonumber(node:getAttribute("speed_y"))        end    end    CCLOG("艹 baseCharacter End")    self.m_onUpdateMoveTime = 0    self.m_onUpdateJumpTime = 0    --self.m_onUpdateHurtStringTime = 0    self.m_onUpdateBuffTime = 0    self.m_onUpdateUseSkillTime = 0    self.m_onUpdateSendPosTime = 0    self.m_onUpdateNpcCollisionTime = 0    self.m_onUpdateZOrderTime = 0    self.m_onUpdateDeadTime = 0    self.m_fLastDangerTime = 0 --危险时间endfunction CBaseCharacter.isSkillCD( self, _skillID )    if self.m_SkillCDTab[ tonumber(_skillID) ] == nil then        return false    else        return _G.pDateTime:getTotalMilliseconds() < self.m_SkillCDTab[ tonumber(_skillID) ]    endendfunction CBaseCharacter.setSkillCD( self, _skillID, _fCooldownInterval )    local nSkill = tonumber(_skillID)    local fCD = tonumber(_fCooldownInterval) * 1000     --秒转毫秒    fCD = fCD + _G.pDateTime:getTotalMilliseconds()    self.m_SkillCDTab[ tonumber(_skillID) ] = fCDendfunction CBaseCharacter.getSkinID( self )    return self.m_SkinIdend --人物边界值  用于判断越过地图function CBaseCharacter.setBorder( self )    local collider = self : getCollider()    if collider == nil then        return    end    self.m_nBorder = collider.vWidth + collider.offsetXendfunction CBaseCharacter.getBorder( self )    return self.m_nBorderendfunction CBaseCharacter.getMonsterXMLID( self )    return self.m_nMonsterXMLID or 0endfunction CBaseCharacter.setMonsterXMLID( self, _xmlID )    self.m_nMonsterXMLID = _xmlIDendfunction CBaseCharacter.getLv( self )    return self.m_nLvendfunction CBaseCharacter.setLv( self, _nLv )    self.m_nLv = _nLvendfunction CBaseCharacter.setXSpeedZero( self )    self.m_fXSpeed = nilendfunction CBaseCharacter.setArenaHp( self )    self.m_nMaxHP = self.m_nMaxHP * _G.Constant.CONST_ARENA_ATTR_HP_TIMES    self : setFull()end-- {设置碰撞机}function CBaseCharacter.setColliderXmlByID( self, _colliderID )    local xmlCollider =  self : getXMLCollider( _colliderID )    self : setCollider( xmlCollider )end--根据人物皮肤设置碰撞机function CBaseCharacter.setColliderXml( self, _nStatus, _skinID )    if self.xmlChar == nil then        self.xmlChar = self:getXmlCharacter( _skinID )    end    if self.xmlChar:isEmpty()then        return    end    local id = nil    if _nStatus == _G.Constant.CONST_BATTLE_STATUS_IDLE then        id = tonumber( self.xmlChar:getAttribute("idle_c"))    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_MOVE then        id = tonumber( self.xmlChar:getAttribute("move_c"))    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_JUMPATTACK then        id = tonumber( self.xmlChar:getAttribute("jumpattack_c"))    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_JUMP then        id = tonumber( self.xmlChar:getAttribute("jump_c"))    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_HURT then        id = tonumber( self.xmlChar:getAttribute("hurt_c"))    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_CRASH then        id = tonumber( self.xmlChar:getAttribute("crash_c") )    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_FALL then        id = tonumber( self.xmlChar:getAttribute("fall_c") )    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_DEAD then        id = nil    end    self : setColliderXmlByID( id )endfunction CBaseCharacter.releaseResource( self )    if self.m_lpMovieClip ~= nil then        if self.m_lpMovieClip : retainCount() >= 1 then            self.m_lpMovieClip:release()        end    end    if self.m_lpMovieClipBattle ~= nil then        if self.m_lpMovieClipBattle : retainCount() >= 1 then            self.m_lpMovieClipBattle : release()        end    end    self : getContainer() : removeFromParentAndCleanup( true )end-- 读Characterfunction CBaseCharacter.getXmlCharacter( self, _nSkinID)    local a = _G.Config : load("config/character.xml")    print("getXmlCharacter",_G.Config.characters)    return _G.Config.characters:selectSingleNode( "character[@id="..tostring( _nSkinID ).."]" )endfunction CBaseCharacter.getXMLCollider( self, _nColliderID )    if _nColliderID == nil then        return    end    return _G.g_SkillColliderXmlManager : getByID(_nColliderID)end--析构function CBaseCharacter.onDestory(self)endfunction CBaseCharacter.animationCallFunc( self,eventType, arg0, arg1, arg2, arg3  )    if eventType == "AnimationComplete" then        self:onAnimationCompleted( eventType, arg0 )    end    if eventType == "Enter" and self.m_isFirstEnter == true then        self : Enter()        CCLOG("艹3")    endendfunction CBaseCharacter.loadMovieClip( self, _skinID )    if _skinID == 1 then        return    end    local function CallFunc( eventType, arg0, arg1, arg2, arg3 )        self : animationCallFunc( eventType, arg0, arg1, arg2, arg3 )    end    self.m_lpMovieClip = nil    self.m_lpMovieClipBattle = nil    local normalStr = "CharacterMovieClip/"..tostring( _skinID ).."_normal.ccbi"    local battleStr = "CharacterMovieClip/"..tostring( _skinID ).."_battle.ccbi"    if self.m_nType == _G.Constant.CONST_TRANSPORT or self.m_nType == _G.Constant.CONST_NPC then        if _G.PathCheck : check( normalStr ) == false then           -- CCMessageBox("locadMovieClip : "..tostring(self.m_szName).." skinID  : "..tostring(_skinID), "this loadError 1")            CCLOG("codeError!!!!  locadMovieClip : "..tostring(self.m_szName).." skinID  : "..tostring(_skinID).." this loadError 1")            CCLOG("艹4")            return        end        self.m_lpMovieClip = CMovieClip:create(normalStr)        self.m_lpMovieClip : retain()        self.m_lpMovieClip : setControlName(normalStr)        self.m_lpMovieClip : registerControlScriptHandler( CallFunc, "this CBaseCharacter self.m_lpMovieClip 185"..tostring(self:getName()))        self.m_lpMovieClipContainer : addChild(self.m_lpMovieClip)        self.m_nStatus = _G.Constant.CONST_BATTLE_STATUS_IDLE    elseif self.m_nType == _G.Constant.CONST_VITRO then        self.m_lpMovieClipBattle = CMovieClip:create(battleStr)        self.m_lpMovieClipBattle : setControlName( battleStr )        self.m_lpMovieClipBattle : retain()        self.m_lpMovieClipBattle : registerControlScriptHandler( CallFunc, "this CBaseCharacter self.m_lpMovieClipBattle 195"..tostring(self:getName()))        self.m_lpMovieClipContainer : addChild(self.m_lpMovieClipBattle)    else        if _G.PathCheck : check( normalStr ) == false or _G.PathCheck : check( battleStr ) == false then            --CCMessageBox("locadMovieClip : "..tostring(self.m_szName).." skinID  : "..tostring(_skinID), "this loadError 2")            CCLOG("codeError!!!!  locadMovieClip : "..tostring(self.m_szName).." skinID  : "..tostring(_skinID).." this loadError 2")            CCLOG("艹5")            return        end        self.m_lpMovieClip = CMovieClip:create(normalStr)        self.m_lpMovieClip : setControlName( normalStr )        self.m_lpMovieClip : retain()        if _G.g_Stage : getScenesType() ~= _G.Constant.CONST_MAP_TYPE_CITY then            self.m_lpMovieClipBattle = CMovieClip:create(battleStr)            self.m_lpMovieClipBattle : setControlName( battleStr )            self.m_lpMovieClipBattle : retain()            self.m_lpMovieClipBattle : registerControlScriptHandler( CallFunc, "this CBaseCharacter self.m_lpMovieClipBattle 195"..tostring(self:getName()))        end        self.m_lpMovieClip : registerControlScriptHandler( CallFunc, "this CBaseCharacter self.m_lpMovieClip 196"..tostring(self:getName()))        self.m_lpMovieClipContainer : addChild(self.m_lpMovieClip)    end    self.m_lpCurrentMovieClip = self.m_lpMovieClip    CCLOG("艹6")end--动作完成后function CBaseCharacter.onAnimationCompleted( self, eventType, _animationName )    local animationName = string.gsub( _animationName , "skill_(%d+)", "%1")    local nSkillID = tonumber(animationName)    if nSkillID ~= nil then  --使用了技能并完成        self.m_nSkillDuration = 0        self.m_nSkillID = 0        self:setStatus(Constant.CONST_BATTLE_STATUS_IDLE)        if self.m_nNextSkillID ~= 0 then            self:useSkill( self.m_nNextSkillID )            self.m_nNextSkillID = self.m_nNextSkillID2            self.m_nNextSkillID2 = 0        end    end    if _animationName == "dead" then        CCLOG("死亡 ".."人物")        self : removeShadow()        self : getStage() : removeCharacter( self )        return    end    if _animationName == "fall" then        --self.m_nMaxTenacity = 20        if self:getType() == _G.Constant.CONST_MONSTER and tonumber(self : getMonsterRank()) ~= _G.Constant.CONST_OVER_BOSS then            self.m_nMaxTenacity = self.m_nMaxTenacityB        elseif self:getType() == _G.Constant.CONST_PLAYER then            self.m_nMaxTenacity = _G.Constant.CONST_WAR_TOUNGHNESS1        end        --倒地后，角色为无敌（10001），其它为霸体一段时间（10002）        if _G.g_Stage:getScenesType() ~= _G.Constant.CONST_MAP_TYPE_CHALLENGEPANEL then            if self:getType() == _G.Constant.CONST_PLAYER then                local invBuff = buffManager:getBuffNewObject( "10001", 0 )                local _flashTime = invBuff:getduration()                self:addBuff(invBuff)                --增加闪的特效一段时间                local blinkact = CCBlink:create( _flashTime, math.floor(_flashTime * 9))                self.m_lpMovieClipContainer:runAction(blinkact)            else                local invBuff2 = buffManager:getBuffNewObject( "10002", 0 )                self:addBuff(invBuff2)            end        end        self.m_nNextSkillID = 0        self.m_nNextSkillID2 = 0        --起身技能        self:setStatus(Constant.CONST_BATTLE_STATUS_IDLE)        if self.m_nStandupSkillID ~= nil and self.m_nStandupSkillID ~= 0 then            if self.m_nTarget ~= nil then --如果目标不为空。则朝向目标使用                if self:getLocationX() < self.m_nTarget:getLocationX() then                    self:setMoveClipContainerScalex(1)                else                    self:setMoveClipContainerScalex(-1)                end            end            self:useSkill( self.m_nStandupSkillID )            self.m_nStandupSkillID = 0            return        end    end    if _animationName == "hurt" then        if self:getLocationZ() <= 0 then            self:setStatus(_G.Constant.CONST_BATTLE_STATUS_IDLE)        end    end    -- if _animationName == "idle" then    --     --CCLOG("idle,idle,idle,idle,idle,idle TEST  "..tonumber(self : getID()).."   "..tostring(self : getName()) )    --     self.m_nStatus = -100    --     self:setStatus(_G.Constant.CONST_BATTLE_STATUS_IDLE)    -- endendfunction CBaseCharacter.setMovePos( self, _movePos )    if _movePos ~= nil then        if self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_HURT           or self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_CRASH           or self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_FALL           or self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_DEAD then            return        end        local stage = self : getStage()        self.m_lpMovePos = _movePos        self : getStage() : onRoleMove( self, self.m_lpMovePos.x, self.m_lpMovePos.y, self : getLocationZ(), true )    endendfunction CBaseCharacter.cancelMove( self )    self.m_lpMovePos = nil    if self : getStatus() == Constant.CONST_BATTLE_STATUS_MOVE then        self : setStatus(Constant.CONST_BATTLE_STATUS_IDLE)    end    self : getStage() : onRoleMove( self, self: getLocationX(), self : getLocationY(), self : getLocationZ(), true, true )endfunction CBaseCharacter.getID( self )    return self.m_nIDendfunction CBaseCharacter.getCurrentSpeed( self, _pos )    --经过结算后得到的速度    local characterPos = ccp( self:getLocationXY() )    local distance = ccpDistance( characterPos,  _pos )    if distance <= 0 then -- 如果距离为0 或者小于0 那么就不成立        return 0    end    local angle = math.abs(CMath : pointsToAngle( _pos,characterPos ) )    local radian = CMath:angleToRadian( angle )    local speedx = math.abs( math.cos(radian) ) * self.m_nMoveSpeedX    local speedy = math.abs( math.sin(radian) ) * self.m_nMoveSpeedY    local speed = math.sqrt( math.pow(speedx, 2) + math.pow(speedy, 2))    -- if angle > _G.Constant.CONST_INIT_Y_ANGLE_MIN and angle <= _G.Constant.CONST_INIT_Y_ANGLE_MAX then --f    --     speed = _G.Constant.CONST_INIT_MOVE_Y_SPEED + self : getSpeedByBuff( false )    -- else -- x    --     speed = _G.Constant.CONST_INIT_MOVE_X_SPEED + self : getSpeedByBuff( true )    -- end    --speed = _G.Constant.CONST_INIT_MOVE_X_SPEED    return speedendfunction CBaseCharacter.getSpeedByBuff( self, _isX )    --取得buff所加的速度    local id = Constant.CONST_BATTLE_BUFF_SPEEDADD    if self.m_buff[id] ~= nil then        if _isX then            return self.m_buff[id] : speedX()        end        return self.m_buff[id] : speedY()    end    return 0endfunction CBaseCharacter.getType( self )    return self.m_nTypeendfunction CBaseCharacter.setType( self, _nType )    self.m_nType = _nTypeendfunction CBaseCharacter.setNamePos( self )    if self.m_lpName == nil then        return    end    local locationZ = self : getLocationZ()    self.m_lpName : setPosition( ccp( 0, locationZ + 200 ) )endfunction CBaseCharacter.setName( self, _szName )    if _szName == nil then        return    end    self.m_szName = _szName    if self.m_lpNameContainer == nil then        return    end    self.m_lpNameContainer : removeAllChildrenWithCleanup( true )    if self : getType() == _G.Constant.CONST_MONSTER then        return    end    self.m_lpName = CCLabelTTF : create( self.m_szName, "Marker Felt", 21 )    self.m_lpNameContainer : addChild( self.m_lpName )    self : setNamePos()    local color = nil    if tonumber(self : getID()) == tonumber(_G.g_LoginInfoProxy : getUid()) then        color =  _G.g_ColorManager : getRGB(_G.Constant.CONST_COLOR_BLUE )    else        color =  _G.g_ColorManager : getRGB(_G.Constant.CONST_COLOR_GOLD )    end    self : setColor( color )    local property = _G.g_characterProperty : getOneByUid( self : getID(), self : getType() )    local stringWidth = self : getCharCountByUTF8(self.m_szName) * 21    if property ~= nil and property : getVipLv() ~= nil and property : getVipLv() > 0 then        CCSpriteFrameCache : sharedSpriteFrameCache() :addSpriteFramesWithFile("CharacterPanelResources/RoleResurece.plist")        local _vipname      = CSprite :createWithSpriteFrameName( "vip_icon.png" )        local viplv  = tostring( property : getVipLv() )        local length = string.len( viplv)        local vipnameSize  = _vipname :getPreferredSize()        local vipWidth = 0        local vipContainer = CContainer : create()        for i=1, length do            local _tempvip = CSprite :createWithSpriteFrameName( "role_vip_0"..string.sub(viplv,i,i)..".png")            vipContainer :addChild( _tempvip )            local _tempvipSize = _tempvip : getPreferredSize()            vipWidth = vipWidth + _tempvipSize.width / 2            _tempvip : setPosition( vipWidth,0)            vipWidth = vipWidth + _tempvipSize.width / 2        end        _vipname : addChild( vipContainer )        vipContainer : setPosition(0-vipWidth/2, 0)        self.m_lpNameContainer : addChild( _vipname )        local locationZ = self : getLocationZ()        _vipname : setPosition( ccp( 0-stringWidth/2 - vipnameSize.width/2, locationZ + 200 ) )    endendfunction CBaseCharacter.setColor(self, _rgb )    if self.m_lpName ~= nil then        -- print("setColor1")        -- print("_rgb",_rgb, debug.traceback())        self.m_lpName:setColor( _rgb )        -- print("setColor2")    endendfunction CBaseCharacter.getCharCountByUTF8( self, str )    local len = #str;    local left = len;    local cnt = 0;    local arr={0,0xc0,0xe0,0xf0,0xf8,0xfc};    while left ~= 0 do        local tmp=string.byte(str,-left);        local i=#arr;        while arr[i] do            if tmp>=arr[i] then left=left-i;break;end            i=i-1;        end        cnt=cnt+1;    end    return cnt;endfunction CBaseCharacter.getName( self )    return self.m_szNameendfunction CBaseCharacter.getHP( self )    return self.m_nHPendfunction CBaseCharacter.getMaxHp( self )    return self.m_nMaxHPendfunction CBaseCharacter.setMaxHp( self, _nMaxHP )    self.m_nMaxHP = _nMaxHPendfunction CBaseCharacter.getMaxSp( self )    return self.m_nMaxSPendfunction CBaseCharacter.setHP( self, _nHP )    if self.m_nHP == _nHP then        return    end    self.m_nHP = _nHP    self.m_nHP = ( self.m_nHP <= 0 and 0 ) or self.m_nHP    self.m_nHP = ( self.m_nHP > self.m_nMaxHP and self.m_nMaxHP ) or self.m_nHP    if self.m_nHP <= 0 and self : getLocationZ() <= 0 then --地面死亡        --self : setStatus( _G.Constant.CONST_BATTLE_STATUS_DEAD )        local _Angle = _G.Constant.CONST_BATTLE_DEAD_ANGLE        if self : getScaleX() < 0 then            _Angle = -( 90- (math.abs(_Angle) -90) )        end        self:thrust( _G.Constant.CONST_BATTLE_DEAD_SPEED, _Angle , _G.Constant.CONST_BATTLE_DEAD_ACCELERATION )        self:setStatus( _G.Constant.CONST_BATTLE_STATUS_CRASH )    end    if self.m_lpHpSlider ~= nil then        self.m_lpHpSlider : setSliderValue( self.m_nHP / self.m_nMaxHP )        self.m_lpHpString : setString( tostring(self.m_nHP).."/"..tostring(self.m_nMaxHP))    end    if self.m_lpBigHp ~= nil then       self.m_lpBigHp : setHpValue(self : getHP()-1, self.m_nMaxHP )    end    if self.m_nHP <= 0 then        self.m_lpBigHp = nil        if self.m_nType == _G.Constant.CONST_MONSTER then            local monsterRank = self : getMonsterRank()            if monsterRank ~= nil and monsterRank >= _G.Constant.CONST_MONSTER_RANK_BOSS_SUPER then                _G.g_Stage : slowMotion()            end        end        if _G.g_Stage: getScenesType() == _G.Constant.CONST_MAP_TYPE_CHALLENGEPANEL then            if self.m_nType == _G.Constant.CONST_PLAYER then                _G.g_Stage : slowMotion()            end        end    endendfunction CBaseCharacter.addHP( self, _nHP )    self :setHP( self.m_nHP + _nHP )endfunction CBaseCharacter.getSP( self )    return self.m_nSPendfunction CBaseCharacter.setSP( self, _nSP )    self.m_nSP = _nSP    self.m_nSP = ( self.m_nSP <= 0 and 0 ) or self.m_nSP    self.m_nSP = ( self.m_nSP > self.m_nMaxSP and self.m_nMaxSP ) or self.m_nSP    if self.m_lpBigHp ~= nil then        self.m_lpBigHp : setSpValue( self.m_nSP , self.m_nMaxSP )    endendfunction CBaseCharacter.canSubSp( self, _nSP )    return  (self.m_nSP + _nSP) >= 0endfunction CBaseCharacter.addSP( self, _nSP )    self : setSP( self.m_nSP + _nSP )endfunction CBaseCharacter.setFull( self )    self :setHP( self.m_nMaxHP )    self :setSP( self.m_nMaxSP )endfunction CBaseCharacter.getContainer( self )    return self.m_lpContainerendfunction CBaseCharacter.getCharaterContainer( self )    return self.m_lpCharacterContainerendfunction CBaseCharacter.setPos( self )    local x,y = self : getLocationXY()    local z = self : getLocationZ()    self : getContainer() : setPosition( x, y )    self : getCharaterContainer() : setPosition(0,z)endfunction CBaseCharacter.setMoveCallBackTime( self, _fSecond )    -- 设置移动回调时间    self.m_fMoveCallBackTime = _fSecondendfunction CBaseCharacter.getScaleX( self )    return self.m_nScaleXendfunction CBaseCharacter.setScaleX( self ,_ScaleX )    self.m_nScaleX = _ScaleXendfunction CBaseCharacter.setMoveClipContainerScalex( self, _ScaleX )    self : setScaleX( _ScaleX )    local container = self : getCharaterContainer()    container : setScaleX( _ScaleX )    --前面反转..后面跟着反 就是正面    self.m_lpNameContainer : setScaleX( _ScaleX )    self.m_lpHurtStringContainer : setScaleX( _ScaleX )    self.m_lpHpContainer : setScaleX( _ScaleX )endfunction CBaseCharacter.setflipHorizontal( self, _angle )    --反转显示    _angle = math.abs(_angle)    --local container = self : getCharaterContainer()    local scaleX = 1    if _angle > 90 then        scaleX = 1    end    if _angle < 90 then        scaleX = -1    end    self : setMoveClipContainerScalex( scaleX )endfunction CBaseCharacter.setStage( self, _lpStage )    -- 设置舞台    self.m_lpStage = _lpStageendfunction CBaseCharacter.getStage( self )    return self.m_lpStageendfunction CBaseCharacter.onUpdateSendPos( self, _nowTime )    --_nowTime 是毫秒    if self : getStage() == nil then        return    end    if self : getStage() : getPlay() ~= self then        return    end    if self.m_fMoveCallNowTime == nil then        self.m_fMoveCallNowTime = 0    end    local elapsedTime = math.abs( _nowTime - self.m_fMoveCallNowTime )    if elapsedTime < self.m_fMoveCallBackTime * 1000 then        return    end    local nowPos = ccp(self:getLocationXY())    local lastPos = self.m_lpMoveCallBackPos    if (nowPos.x == lastPos.x) and (nowPos.y == lastPos.y) then        self.m_fMoveCallNowTime = _nowTime        return    end    self : getStage() : onRoleMove( self, nowPos.x, nowPos.y, self : getLocationZ() )    self.m_lpMoveCallBackPos = nowPos    self.m_fMoveCallNowTime = _nowTimeendfunction CBaseCharacter.onUpdateNpcCollision( self, _nowTime )    if self : getStage() == nil then        return    end    local nowPos = ccp(self:getLocationXY())    local lastPos = self.m_lpNpcCollisionCallBackPos    if lastPos.x == nowPos.x and lastPos.y == nowPos.y then        return    end    self : getStage() : checkCollisionNPC( self, nowPos.x, nowPos.y )    self.m_lpNpcCollisionCallBackPos = nowPosendfunction CBaseCharacter.onUpdateZOrder( self, _nowTime )    local nowPos = ccp(self:getLocationXY())    local lastPos = self.m_lpZOrderCallBackPos    if (lastPos.x == nowPos.x) and (lastPos.y == nowPos.y) then        return    end    self : setZOrder( -nowPos.y )    self.m_lpZOrderCallBackPos = nowPosendfunction CBaseCharacter.setZOrder( self, _z )    local container = self : getContainer()    if container ~= nil then        container : setZOrder( _z )    endendfunction CBaseCharacter.getLocationX( self )    return self.m_nLocationXendfunction CBaseCharacter.setLocationX( self, _x )    self:setLocation( _x, self:getLocationY(), self:getLocationZ() )endfunction CBaseCharacter.getLocationY( self )    return self.m_nLocationYendfunction CBaseCharacter.setLocationY( self, _y )    self:setLocation( self:getLocationX(), _y, self:getLocationZ() )endfunction CBaseCharacter.getLocationZ( self )    return self.m_nLocationZendfunction CBaseCharacter.setLocationZ( self, _z )    self:setLocation( self:getLocationX(), self:getLocationY(), _z )endfunction CBaseCharacter.setLocationXY( self, _x, _y )    self:setLocation( _x, _y, self:getLocationZ() )endfunction CBaseCharacter.getLocationXY( self )    return self.m_nLocationX, self.m_nLocationYendfunction CBaseCharacter.convertLimitPos( self, _x , _y )    local stage = self : getStage()    if stage ~= nil and stage : getCanControl() == true then        local lx = stage : getMaplx()        if (stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_BOSS or stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_CLAN_BOSS) and self : getType() == _G.Constant.CONST_MONSTER then            --世界BOSS的怪物不能超过这个线            lx = _G.Constant.CONST_BOSS_SECURITY_X + 1        end        local rx = stage : getMaprx()        local border = self : getBorder()        if border ~= nil then            lx = lx + border            rx = rx - border        end        _x = (_x > rx and rx) or _x        _x = (_x < lx and lx) or _x        local maxY = stage : getMapData() : getCanWalkHeight()        _y = _y < 0 and 0 or _y        _y = _y > maxY and maxY or _y    end    return _x,_yendfunction CBaseCharacter.setLocation( self, _x, _y, _z )    _z = _z < 0 and 0 or _z    if _y + _z < _y then        return    end    _x,_y = self : convertLimitPos( _x, _y)    self.m_nLocationX = _x    self.m_nLocationY = _y    self.m_nLocationZ = _z    self : setPos()    self : moveArea()endfunction CBaseCharacter.addBuff( self, _buff )    if not _buff:is(CBuff) then        CCLOG("have some one add buff ,but this object not is CBuff or CBuff extend")        return    end    if _buff : gettype() == _G.Constant.CONST_BATTLE_BUFF_RIGIDITY or _buff : gettype() == _G.Constant.CONST_BATTLE_BUFF_CRASH then        self.m_buff[ tonumber(_G.Constant.CONST_BATTLE_BUFF_RIGIDITY) ] = nil        self.m_buff[ tonumber(_G.Constant.CONST_BATTLE_BUFF_CRASH) ] = nil    end    self.m_buff[ _buff:gettype() ] = _buff    if _buff : gettype() == _G.Constant.CONST_BATTLE_BUFF_THRUST then        --1 自身推力        if _buff.speed ~=nil and _buff.pushAngle ~= nil and _buff.acceleration ~= nil then            local pushAngle = _buff.pushAngle            if self : getScaleX() < 0 then                pushAngle = -( 90- (math.abs(_buff.pushAngle) -90) )            end            self : thrust( _buff.speed, pushAngle, _buff.acceleration )        end    end    if _buff : gettype() == _G.Constant.CONST_BATTLE_BUFF_VIBRATE then        if self == _G.g_Stage : getPlay() or self : getType() == _G.Constant.CONST_MONSTER then            if self : getType() == _G.Constant.CONST_MONSTER and self : getMonsterRank() < _G.Constant.CONST_MONSTER_RANK_ELITE_LEADER then                return            end            _G.g_Stage : vibrate()        end    endendfunction CBaseCharacter.getBuff( self, _buffType )    return self.m_buff[_buffType]endfunction CBaseCharacter.removeBuff( self, _buffType )    self.m_buff[tonumber(_buffType)] = nil    if tonumber(_buffType) == _G.Constant.CONST_BATTLE_BUFF_HANGIN then        local invBuff = buffManager:getBuffNewObject( "10007", 0 )        self:addBuff(invBuff)    end    if tonumber(_buffType) == _G.Constant.CONST_BATTLE_BUFF_SPRINT then        self.m_nCurrentAcceleration = 0        self.m_fXSpeed = 0        self.m_fYSpeed = 0    endendfunction CBaseCharacter.removeBuffBySkillId( self, _skillId )    local toBeRemoved = {}    for k,v in pairs(self.m_buff) do        if tonumber(v:getSkillId()) == _skillId then            table.insert( toBeRemoved, tonumber(v:gettype()) )        end    end    for i,v in ipairs(toBeRemoved) do        self:removeBuff( v )    end    toBeRemoved = nilendfunction CBaseCharacter.removeAllBuff( self )    self.m_buff = {}endfunction CBaseCharacter.jump( self )    if self :getStatus() == Constant.CONST_BATTLE_STATUS_USESKILL or        self :getStatus() == Constant.CONST_BATTLE_STATUS_JUMP or        self : getLocationZ() > 0 then        return    end    if self : isHaveBuff( _G.Constant.CONST_BATTLE_BUFF_LOCKZ ) then        return    end    self:thrust( _G.Constant.CONST_BATTLE_JUMP_THRUST, -90, _G.Constant.CONST_BATTLE_JUMP_ACCELERATION)    self:setStatus(_G.Constant.CONST_BATTLE_STATUS_JUMP)    local x = self : getLocationX()    local y = self : getLocationY()    if self.m_lpMovePos ~= nil then        x = self.m_lpMovePos.x        y = self.m_lpMovePos.y    end    self : getStage() : onRoleMove( self, x, y, 10, true )endfunction CBaseCharacter.useSkill(self, _nSkillID)    if self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_JUMPATTACK       or self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_HURT       or self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_CRASH       or self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_FALL       or self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_DEAD then        return    end    if self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_USESKILL and _nSkillID == self.m_nSkillID then        return    end    if self : isHaveBuff( _G.Constant.CONST_BATTLE_BUFF_SILENCE ) then        --沉默中不能使用技能        return    end    local moveClip = self : getBattleMoveClip()    if _nSkillID == 10013 or _nSkillID == 10023 or _nSkillID == 10033 or _nSkillID == 10043 then        if self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_JUMP then            self:setStatus(_G.Constant.CONST_BATTLE_STATUS_JUMPATTACK)            local moveClipParnet = nil--moveClip : getParent()            if moveClip ~= nil then                moveClipParnet = moveClip : getParent()            end            if moveClipParnet ~= nil then                moveClip : play( "jumpattack" )            end            self.m_nSkillDuration = 0            self.m_nSkillID = _nSkillID        end    elseif _nSkillID == self.m_nJumpAttackSkillId and self:getLocationZ() <= 0 then        print("useSkill 2")        return    elseif self.m_nSkillID == 0 then        print("useSkill 3")        if self == _G.g_Stage:getPlay() or _G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_CHALLENGEPANEL then            --如果是主角使用技能的话,通知界面CD冷却            --获取CD时间            local skillNode = _G.g_SkillEffectXmlManager : getByID( _nSkillID )            if skillNode == nil then                return            end            local sp = skillNode.sp            if self : canSubSp( -sp ) == false then                return            end            self : addSP( -sp )            if self == _G.g_Stage:getPlay() then                local vo_data = VO_SkillCDModel( _nSkillID, skillNode.cd)                local cd_Command = CKeyBoardSkillCDCommand( vo_data )                controller:sendCommand(cd_Command)                --设置本身CD                self:setSkillCD( _nSkillID, skillNode.cd )            end        end        self:setStatus( _G.Constant.CONST_BATTLE_STATUS_USESKILL )        local moveClipParnet = nil--moveClip : getParent()        if moveClip ~= nil then            moveClipParnet = moveClip : getParent()        end        if _nSkillID == self.m_nJumpAttackSkillId then            return        end        if moveClipParnet ~= nil then            moveClip : play( "skill_"..tostring(_nSkillID) )        end        --self.m_lpCurrentMovieClip : play("skill_"..tostring(_nSkillID))        self.m_nSkillDuration = 0        self.m_nSkillID = _nSkillID    else        print("useSkill 4")        if _nSkillID ~= self.m_nJumpAttackSkillId then            self.m_nNextSkillID = _nSkillID        end    end    self.m_nTenacity = 0    self : sendToServerUseSkill( _nSkillID )endfunction CBaseCharacter.sendToServerUseSkill( self, _nSkillID )    local selfProperty = _G.g_characterProperty : getOneByUid( self : getID(), self : getType() )    if selfProperty == nil then        CCLOG("sendToServerUseSkill selfProperty is nil")        return    end    if tonumber(selfProperty : getUid() ) ~= _G.g_characterProperty : getMainPlay() : getUid() then        return    end    if _G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_BOSS        or _G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_CLAN_BOSS        or selfProperty : getIsTeam() == true        or _G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_INVITE_PK then        local uid = self : getID()        if self : getType() == _G.Constant.CONST_PARTNER then            uid = selfProperty : getPartner()        end        local comm = CStageREQCommand(_G.Protocol["REQ_WAR_USE_SKILL"])        comm : setOtherData( {type=self:getType(),id=uid,skill_id=_nSkillID,skill_lv=1} )        _G.controller : sendCommand( comm )    endendfunction CBaseCharacter.onHurt(self, isSkill, isCrash)    local hurtX = tonumber(self.xmlChar:getAttribute("hurt_x"))    local hurtY = tonumber(self.xmlChar:getAttribute("hurt_y"))    if self.m_hurtMovieClip == nil then        local function onHurtEffectCallback(eventType, _animationName)            if eventType == "AnimationComplete" then                if _animationName == "effect_hurt" then                    self.m_hurtMovieClip:removeFromParentAndCleanup(true)                    self.m_hurtMovieClip = nil                end            end        end        self.m_hurtMovieClip = CMovieClip:create("CharacterMovieClip/effect_hurt.ccbi")        self.m_hurtMovieClip:setPosition( ccp(hurtX, hurtY) )        self.m_hurtMovieClip:registerControlScriptHandler( onHurtEffectCallback )        self.m_lpCharacterContainer:addChild( self.m_hurtMovieClip, 10 )    end    self.m_hurtMovieClip:play("effect_hurt")    self.m_nNextSkillID = 0    self.m_nNextSkillID2 = 0------------------------------------韧性判断    if isSkill == true or isCrash == true then        if self:getType() == _G.Constant.CONST_MONSTER and tonumber(self : getMonsterRank()) ~= _G.Constant.CONST_OVER_BOSS then            self.m_nMaxTenacity = self.m_nMaxTenacityA        elseif self:getType() == _G.Constant.CONST_PLAYER then            self.m_nMaxTenacity = _G.Constant.CONST_WAR_TOUNGHNESS2        end    end    if self:getType() == _G.Constant.CONST_MONSTER then        self.m_nTenacity = self.m_nTenacity + 1   --当前连续受击次数+1    end    if self.m_nMaxTenacity ~= nil and self.m_nMaxTenacity > 0 and self.m_nTenacity > self.m_nMaxTenacity then        if self:getType() == _G.Constant.CONST_MONSTER and tonumber(self : getMonsterRank()) == _G.Constant.CONST_OVER_BOSS then            return        end        --增加霸体BUFF        if self:getLocationZ() > 50 then  --在空中，增加霸体BUFF 10004            local invBuff1 = buffManager:getBuffNewObject( "10004", 0 )            self:addBuff(invBuff1)        else                            --在地上，增加霸体BUFF 10003            local invBuff2 = buffManager:getBuffNewObject( "10003", 0 )            self:addBuff(invBuff2)        end        local invBuff = buffManager:getBuffNewObject( "10005", 0 )        self:addBuff(invBuff)        self.m_nTenacity = 0    endendfunction CBaseCharacter.getMovieClip( self )    return self.m_lpMovieClipendfunction CBaseCharacter.getBattleMoveClip( self )    return self.m_lpMovieClipBattleendfunction CBaseCharacter.setLastDangerTime( self )    -- body    if self:getAI() == nil or self:getAI() == 0 then        return    end    _G.pDateTime : reset()    local nowTime = _G.pDateTime : getTotalMilliseconds() --毫秒数    local child = self.m_lpAINode:children()    local node = child:get(0,"special_areas")    local nextChild = node:children()    local special_area = nextChild:get(0,"special_area")    self.m_fLastDangerTime = nowTime + tonumber(special_area:getAttribute("ti"))endfunction CBaseCharacter.sendFallToServer( self )    if self : getType() ~= _G.Constant.CONST_MONSTER then        return    end    local mainProperty = _G.g_characterProperty : getMainPlay()    if mainProperty == nil or mainProperty : getIsTeam() == false then        return    end    require "common/protocol/auto/REQ_WAR_DOWN"    local msg =  REQ_WAR_DOWN()    msg : setArguments( self : getMonsterXMLID(), self : getID() )    _G.CNetwork : send(msg)endfunction CBaseCharacter.getLaseDangerTime( self )    return self.m_fLastDangerTimeendfunction CBaseCharacter.setStatus(self, _nStatus)    if _nStatus == self.m_nStatus then        return    end    local addMovieClip = nil    local actionName = nil    local tempCollide = nil    if _nStatus == _G.Constant.CONST_BATTLE_STATUS_IDLE then --站立,循环        addMovieClip = self : getMovieClip()        actionName = "idle"    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_MOVE then --移动,循环        addMovieClip = self : getMovieClip()        actionName = "move"    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_HURT then --受击,循环        addMovieClip = self : getBattleMoveClip()        actionName = "hurt"    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_FALL then --倒地,循环        addMovieClip = self : getBattleMoveClip()        actionName = "fall"        self : setLastDangerTime()        self : sendFallToServer()    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_CRASH then --击飞,循环        addMovieClip = self : getBattleMoveClip()        actionName = "crash"    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_JUMP then --跳跃,非循环        addMovieClip = self : getBattleMoveClip()        actionName = "jump"    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_JUMPATTACK then --跳跃普通攻击,非循环        addMovieClip = self : getBattleMoveClip()        actionName = "jumpattack"    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_DEAD then --死亡,非循环        addMovieClip = self : getBattleMoveClip()        self : removeAllBuff()        actionName = "dead"    elseif _nStatus == _G.Constant.CONST_BATTLE_STATUS_USESKILL then --使用技能时,因技能ID不同,外部调用其播放动画        addMovieClip = self : getBattleMoveClip()        --[[ m_lpCurrentContainer 这个值.再使用技能时,会再次修改        ]]    end    if addMovieClip ~= nil then        self.m_nSkillID = 0        local container = self.m_lpMovieClipContainer        if self : getMovieClip() ~= nil then            self : getMovieClip() : removeFromParentAndCleanup( false )        end        if self : getBattleMoveClip() ~= nil then            self : getBattleMoveClip() : removeFromParentAndCleanup( false )        end        container : addChild( addMovieClip )        if actionName ~= nil then            addMovieClip : play( actionName )            if (actionName == "idle" or actionName == "move") and self.m_MagicMC ~= nil then                self.m_MagicMC : play( actionName )                if self.m_MagicMC_before ~= nil then                    self.m_MagicMC_before : play( actionName )                end            end        end        self.m_lpCurrentMovieClip = addMovieClip        self.m_nStatus = _nStatus        self :setColliderXml( self.m_nStatus, self.m_SkinId )    --默认职业为 1 先    endendfunction CBaseCharacter.getStatus( self )    return self.m_nStatusend--给对象推力function CBaseCharacter.thrust(self, _speed, _angle, _acceleration)    if _speed == 0.0 then        CCLOG("_SPPED == 0.0")        return    end    self.m_nCurrentAcceleration = _acceleration    local xRadian = CMath:angleToRadian( 180 + _angle )    self.m_fXSpeed = _speed * math.cos( xRadian )    local yRadian = CMath:angleToRadian( _angle )    self.m_fYSpeed = _speed * math.sin( -yRadian )endfunction CBaseCharacter.onUpdate( self, _duration, _nowTime )-- self.m_onUpdateMoveTime-- self.m_onUpdateJumpTime-- self.m_onUpdateHurtStringTime-- self.m_onUpdateBuffTime-- self.m_onUpdateUseSkillTime-- self.m_onUpdateSendPosTime-- self.m_onUpdateNpcCollisionTime-- self.m_onUpdateZOrderTime-- self.m_onUpdateDeadTime    self : onUpdateMove( _duration )    self : onUpdateJump( _duration )    -- self : onUpdateHurtString( _duration )    self : onUpdateSendPos( _nowTime )    self : onUpdateNpcCollision( _nowTime )    self : onUpdateZOrder( _nowTime )    self : onUpdateBuff( _duration )    self : onUpdateUseSkill( _duration )    self : onUpdateDead()    -- self : onUpdateMove( _duration )    -- self : onUpdateJump( _duration )    -- self : onUpdateHurtString( _duration )    -- self : onUpdateBuff( _duration )    -- self : onUpdateUseSkill( _duration )    -- if self.m_onUpdateSendPosTime + 250 < _nowTime then    --     self : onUpdateSendPos( _nowTime )    --     self : onUpdateNpcCollision( _nowTime )    --     self : onUpdateZOrder( _nowTime )    --     self : onUpdateDead( _nowTime )    --     self.m_onUpdateSendPosTime = _nowTime    -- endendfunction CBaseCharacter.onUpdateDead( self )    if _G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_CITY then        return    end    if self : getHP() > 0 then        return    end    local z = self : getLocationZ()    if z > 0 then        return    end    self : setStatus( _G.Constant.CONST_BATTLE_STATUS_DEAD )end-- function CBaseCharacter.onUpdateHurtString( self, _duration )    --未定义常量    -- local removeList = {}    -- if self.m_lpHurtStringList == nil then    --     return    -- end    -- for k, hurtString in pairs( self.m_lpHurtStringList ) do    --     if hurtString ~= nil then    --         local x,y = hurtString : getPosition()    --         y = y + 200 * _duration    --         if y >= 300 then    --             removeList[k] = hurtString    --         else    --             hurtString : setPosition( ccp( x, y ) )    --         end    --     end    -- end    -- for k,hurtString in pairs(removeList) do    --     self.m_lpHurtStringContainer : removeChild( hurtString )    --     self.m_lpHurtStringList[k] = nil    -- end-- endfunction CBaseCharacter.onUpdateBuff(self, _duration)    local removeList = {}    for k,buff in pairs(self.m_buff) do        if buff.update ~= nil then            buff : update(_duration)        end        --过期BUFF        if buff : isTimeOut() == true then            table.insert( removeList, k )        --流血状态 11        elseif buff : gettype() == _G.Constant.CONST_BATTLE_BUFF_BLEED then            if buff.m_fSecond == nil then                buff.m_fSecond = 0            end            if buff.m_fSecond <= buff.m_fDuration + 1 then                buff.m_fSecond = buff.m_fDuration + 1                if self : isHaveBuff( _G.Constant.CONST_BATTLE_BUFF_INVINCIBLE ) == nil then                    self : addHP( -buff.hp )                end            end        end    end    local bIdle = false    for k,buffID in pairs(removeList) do        if tonumber(buffID) == _G.Constant.CONST_BATTLE_BUFF_RIGIDITY and self:getLocationZ() <= 0 then            bIdle = true        elseif tonumber(buffID) == _G.Constant.CONST_BATTLE_BUFF_CRASH then            bIdle = false        else            bIdle = false        end        self : removeBuff( buffID )    end    if bIdle == true then        self:setStatus(_G.Constant.CONST_BATTLE_STATUS_IDLE)    endendfunction CBaseCharacter.onUpdateUseSkill(self, _duration)    if self.m_nStatus ~= Constant.CONST_BATTLE_STATUS_USESKILL and self.m_nStatus ~= Constant.CONST_BATTLE_STATUS_JUMPATTACK then        return    end    local lastDuration = self.m_nSkillDuration    self.m_nSkillDuration = self.m_nSkillDuration + _duration    --循环配置表    local skillNode = _G.g_SkillEffectXmlManager : getByID( self.m_nSkillID )    if skillNode == nil then        return    end    for _,currentFrame in pairs(skillNode.frame) do        local currentFrameTime = currentFrame.time        if currentFrameTime >= lastDuration and currentFrameTime < self.m_nSkillDuration then            --时间在此之内,则结算当前帧 只运行当前次 然后到下一个            --检查当前FRAME 的buff添加自身和删除自身未发生碰撞            self : handleSkillFrameEffect( currentFrame )            self : setColliderXmlByID( currentFrame.be_collider )            self : handleSkillFrameBuff( currentFrame, 1 ,0, self.m_nSkillID )            _G.StageXMLManager : handleSkillFrameVitro( self, currentFrame )            --技能攻击音效            if currentFrame.sound ~= nil and currentFrame.sound ~= 0 then                if _G.pCSystemSettingProxy:getStateByType(_G.Constant.CONST_SYS_SET_MUSIC) == 1 then                    SimpleAudioEngine:sharedEngine():playEffect("Sound@mp3/"..tostring(currentFrame.sound)..".mp3", false)                end            end            local iscollider = self : checkCollisionSkill( skillNode, currentFrame )            self : removeThrustBuff()            --添加连击            if ( (iscollider == true)and(_G.g_Stage : isMainPlay( self ) == true) ) or (_G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_CHALLENGEPANEL) then                --打中一次，播放一次受击音效                if _G.pCSystemSettingProxy:getStateByType(_G.Constant.CONST_SYS_SET_MUSIC) == 1 then                    SimpleAudioEngine:sharedEngine():playEffect("Sound@mp3/Hit.mp3", false)                end                if _G.g_Stage : isMainPlay( self ) == true then                    _G.g_Stage : addCombo()                end                self : addSP(_G.Constant.CONST_BATTLE_HOST_HIT_SP)            end            -- --如果是离体攻击的一次碰撞            -- if (iscollider == true) and self:getType() == _G.Constant.CONST_BATTLE_FLYCOLLIDER_2 then            --     _G.g_Stage : removeCharacter( self )            --     return            -- end        end    endendfunction CBaseCharacter.handleSkillFrameEffect( self, _currentFrame )    for _,_currentEffect in pairs(_currentFrame.effect) do        self : addSkillEffect( _currentEffect.fileName,            _currentEffect.posX,                _currentEffect.posY,                _currentEffect.delTime )    endendfunction CBaseCharacter.addSkillEffect( self, _pathName, _x, _y, _delTime  )    local autoDelTime = _delTime    local effectCCBI = CMovieClip : create( "CharacterMovieClip/"..tostring(_pathName).."_battle.ccbi" )    local function onFunc( eventType, arg0, arg1, arg2, arg3 )        if eventType == "AnimationComplete" then            if autoDelTime == nil then                effectCCBI : removeFromParentAndCleanup( true )                effectCCBI = nil            end        end        if eventType == "Enter" then            effectCCBI : play( "skill_".._pathName )        end    end    effectCCBI : registerControlScriptHandler( onFunc, "this CBaseCharacter addSkillEffect ".._pathName)    self.m_lpEffectContainer : addChild( effectCCBI )    effectCCBI : setPosition( _x, _y )    if autoDelTime ~= nil then        local function onAotuDel( )            effectCCBI : removeFromParentAndCleanup( true )            effectCCBI = nil        end        local _callBacks = CCArray:create()        _callBacks:addObject(CCDelayTime:create( autoDelTime ))        _callBacks:addObject(CCCallFunc:create(onAotuDel))        effectCCBI : runAction( CCSequence:create(_callBacks) )    endendfunction CBaseCharacter.removeThrustBuff( self )    --推力BUFF一定要在完成加入和碰撞 后删除.    self : removeBuff( _G.Constant.CONST_BATTLE_BUFF_RIGIDITY )    self : removeBuff( _G.Constant.CONST_BATTLE_BUFF_CRASH )endfunction CBaseCharacter.handleSkillFrameBuff( self, _currentFrame, _isPersonal, _iscollision, _skillId )    --处理当前技能帧的BUFF  _isPersonal 1 自己  0 他人    --_iscollision 1 撞了   0 没撞    for _,currentBuff in pairs(_currentFrame.buff) do        if currentBuff.personal == _isPersonal and currentBuff.collision == _iscollision then            print("currentBuff.id",currentBuff.id,_skillId)            local buffObject = _G.buffManager : getBuffNewObject( currentBuff.id ,_skillId )            self : addBuff( buffObject )        end    end    for _,currentdeBuff in pairs(_currentFrame.debuff) do        if currentdeBuff.personal == tonumber(_isPersonal) then            self : removeBuff( currentdeBuff.id )        end    endendfunction CBaseCharacter.onUpdateMove( self, _duration )    --移动    if self.m_lpMovePos == nil then        return    end    if self : getHP() <= 0 then        return    end    if self : getStatus() == _G.Constant.CONST_BATTLE_STATUS_FALL        or self : getStatus() == _G.Constant.CONST_BATTLE_STATUS_HURT        or self : getStatus() == _G.Constant.CONST_BATTLE_STATUS_CRASH        or self : getStatus() == _G.Constant.CONST_BATTLE_STATUS_DEAD then        --倒地不能移动        self : cancelMove()        return    end    local x = self : getLocationX()    local y = self : getLocationY()    local characterDistance = ccpDistance( ccp(x, y), self.m_lpMovePos )    if characterDistance <= 0 then        self.m_lpMovePos = nil        return    end    local angel = CMath : pointsToAngle ( self.m_lpMovePos , ccp (x,y) )    local radian = CMath : angleToRadian( angel )    local speed = self:getCurrentSpeed( self.m_lpMovePos )    local movePosX = x - speed * _duration * math.cos( radian )    local movePosY = y - speed * _duration * math.sin( radian )    local moveDistance = ccpDistance( ccp(x,y), ccp(movePosX, movePosY) )    if characterDistance <= moveDistance then        movePosX = self.m_lpMovePos.x        movePosY = self.m_lpMovePos.y        self.m_lpMovePos = nil    end    if self : isHaveBuff( _G.Constant.CONST_BATTLE_BUFF_LOCKX ) then        movePosX = self : getLocationX()    end    if self : isHaveBuff( _G.Constant.CONST_BATTLE_BUFF_LOCKY ) then        movePosY = self : getLocationY()    end    if self : getStatus() == Constant.CONST_BATTLE_STATUS_IDLE then        self : setStatus(Constant.CONST_BATTLE_STATUS_MOVE)    end    if self.m_lpMovePos == nil then        self : cancelMove()    end    if movePosX ~= x then        self : setflipHorizontal( angel )    end    self : setLocation( movePosX, movePosY, self : getLocationZ() )endfunction CBaseCharacter.moveArea( self )    local stage = self : getStage()    if stage ~= nil then        local play = stage :getPlay()        if self == play then            --是本玩家才执行            stage : moveArea( self : getLocationXY() )        end    endendfunction CBaseCharacter.onUpdateJump( self, _duration )    if self : isHaveBuff(_G.Constant.CONST_BATTLE_BUFF_SPRINT) == true and self.m_fXSpeed ~= nil then        local moveToX = self :getLocationX() + self.m_fXSpeed * _duration        self : setLocationX( moveToX )    end    -- 跳跃    if self.m_fYSpeed == nil then        return    end    local ySpeed = self.m_fYSpeed    local yDistance = ySpeed * _duration  - (0.5 * self.m_nCurrentAcceleration * _duration * _duration)    self.m_fYSpeed = self.m_fYSpeed - ( self.m_nCurrentAcceleration  * _duration)    local moveToZ = self : getLocationZ()    if self:isHaveBuff( _G.Constant.CONST_BATTLE_BUFF_HANGIN ) == nil then        moveToZ = moveToZ + yDistance        moveToZ = moveToZ < 0 and 0 or moveToZ        self : setLocationZ(moveToZ)        if self : isHaveBuff(_G.Constant.CONST_BATTLE_BUFF_SPRINT) == nil and moveToZ > 0 and self.m_fXSpeed ~= nil then            local moveToX = self :getLocationX() + self.m_fXSpeed * _duration            self : setLocationX( moveToX )        end    end    if moveToZ <= 0 then        self.m_fYSpeed = nil        if self : isHaveBuff(_G.Constant.CONST_BATTLE_BUFF_SPRINT) == nil then            self.m_fXSpeed = nil        end        if self : getStatus() == _G.Constant.CONST_BATTLE_STATUS_CRASH then            self:setStatus(_G.Constant.CONST_BATTLE_STATUS_FALL)        end        if self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_HURT and self : getHP() > 0 then            self : setStatus(_G.Constant.CONST_BATTLE_STATUS_IDLE)        end        if self : getStatus() == _G.Constant.CONST_BATTLE_STATUS_JUMP            or self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_JUMPATTACK then            self : setStatus(_G.Constant.CONST_BATTLE_STATUS_IDLE)        end        if self : getHP() <= 0 then --空中死亡            self : setStatus( _G.Constant.CONST_BATTLE_STATUS_DEAD )        end    endendfunction CBaseCharacter.setShadow( self, _lzShadowName )    CCSpriteFrameCache : sharedSpriteFrameCache() : addSpriteFramesWithFile( "UniversalScenes/UniversalScenes.plist" )    if self.m_lpShadow ~= nil then        self.m_lpShadowContainer:removeChild(self.m_lpShadow)    end    self.m_lpShadow = CSprite : createWithSpriteFrameName( _lzShadowName )    self.m_lpShadow : setControlName( "this CBaseCharacter self.m_lpShadow 930 ")    self.m_lpShadowContainer : addChild( self.m_lpShadow )endfunction CBaseCharacter.removeShadow( self )    self.m_lpShadowContainer : removeChild( self.m_lpShadow, false )endfunction CBaseCharacter.setCollider( self, _collider )    self.m_lpCurrentCollider = _colliderendfunction CBaseCharacter.getCollider( self )    return self.m_lpCurrentColliderendfunction CBaseCharacter.getWorldCollider( self )    local colliderNode = self:getCollider()    if colliderNode == nil then        return    end    if self : getContainer() == nil then        return    end    local scaleX = self : getScaleX()    local vWidth = colliderNode.vWidth    local vX = nil    if scaleX > 0 then        vX = colliderNode.offsetX + self:getLocationX()    else        vX = colliderNode.offsetX * scaleX + self:getLocationX() - vWidth    end    local vY = colliderNode.offsetY + self:getLocationY()    local vZ = colliderNode.offsetZ + self:getLocationZ()    local vHeight = colliderNode.vHeight    local vRange = colliderNode.vRange    return vX, vY, vZ, vWidth, vHeight, vRangeend--技能相关function CBaseCharacter.setSkillID( self, nAttackSkillId1, nAttackSkillId2, nAttackSkillId3, nJumpAttackSkillId, nSkill1, nSkill2, nSkill3, nSkill4, nSkill5, nSkill6 )    self.m_nAttackSkillId1 = nAttackSkillId1    self.m_nAttackSkillId2 = nAttackSkillId2    self.m_nAttackSkillId3 = nAttackSkillId3    self.m_nJumpAttackSkillId = nJumpAttackSkillId    self.m_nSkill1 = nSkill1    self.m_nSkill2 = nSkill2    self.m_nSkill3 = nSkill3    self.m_nSkill4 = nSkill4    self.m_nSkill5 = nSkill5    self.m_nSkill6 = nSkill6endfunction CBaseCharacter.getAttackSkillID( self )    if self.m_nSkillID == 0 and self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_JUMP then        return self.m_nJumpAttackSkillId    elseif self:getStatus() == _G.Constant.CONST_BATTLE_STATUS_JUMPATTACK then        return self.m_nJumpAttackSkillId    end    if self.m_nSkillID == 0 then        return self.m_nAttackSkillId1    elseif self.m_nSkillID == self.m_nAttackSkillId1 then        local skillNode1 = _G.g_SkillEffectXmlManager : getByID( self.m_nSkillID )        if skillNode1 == nil then            return 0        end        if skillNode1.chaincd ~= nil and self.m_nSkillDuration >= skillNode1.chaincd then            return self.m_nAttackSkillId2        else            return 0        end    elseif self.m_nSkillID == self.m_nAttackSkillId2 then        local skillNode2 = _G.g_SkillEffectXmlManager : getByID( self.m_nSkillID )        if skillNode2 == nil then            return 0        end        if skillNode2.chaincd ~= nil and self.m_nSkillDuration >= skillNode2.chaincd then            return self.m_nAttackSkillId3        else            return 0        end    else        return 0    endendfunction CBaseCharacter.getJumpAttackSkillID( self )    return self.m_nJumpAttackSkillIdendfunction CBaseCharacter.getSkillID1( self )    return self.m_nSkill1endfunction CBaseCharacter.getSkillID2( self )    return self.m_nSkill2endfunction CBaseCharacter.getSkillID3( self )    return self.m_nSkill3endfunction CBaseCharacter.getSkillID4( self )    return self.m_nSkill4endfunction CBaseCharacter.getSkillID5( self )    return self.m_nSkill5endfunction CBaseCharacter.getSkillID6( self )    return self.m_nSkill6endfunction CBaseCharacter.setLeaderUID( self, _leaderUid )    self.m_nLeaderUid = _leaderUidendfunction CBaseCharacter.getLeaderUID( self )    return self.m_nLeaderUidendfunction CBaseCharacter.getConvertCollider( self, _collider, _isFlip )    local collider = _collider    if type(_collider) ~= "table" then        collider = {}        collider.offsetX = _collider:getAttribute("offsetX")        collider.offsetY = _collider:getAttribute("offsetY")        collider.offsetZ = _collider:getAttribute("offsetZ")        collider.vWidth = _collider:getAttribute("vWidth")        collider.vHeight = _collider:getAttribute("vHeight")        collider.vRange = _collider:getAttribute("vRange")    end    if collider == nil then        return    end    local scaleX = self : getScaleX()    local vWidth = tonumber( collider.vWidth )    local vX = nil    if _isFlip == true then        scaleX = -scaleX    end    if scaleX > 0 then        vX = tonumber( collider.offsetX ) + self:getLocationX()    else        vX = tonumber( collider.offsetX ) * scaleX + self:getLocationX() - vWidth    end    local vY = tonumber( collider.offsetY ) + self:getLocationY()    local vZ = tonumber( collider.offsetZ ) + self:getLocationZ()    local vHeight = tonumber( collider.vHeight )    local vRange = tonumber( collider.vRange )    return vX, vY, vZ, vWidth, vHeight, vRangeendfunction CBaseCharacter.checkCollisionSkill( self, _skillNode, _currentFrame )    local currentCollider = self : getXMLCollider( _currentFrame.collider )    if currentCollider == nil then        return false    end    --上面找出collider碰撞数据    local iscollider = false    local characterList = _G.CharacterManager : getCharacterByVertex( self , currentCollider )    if self : getLocationX() <= _G.Constant.CONST_BOSS_SECURITY_X and (_G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_BOSS or _G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_CLAN_BOSS ) then        return false    end    local masterUid = self : getID()    local masterType = self : getType()    if self : getType() == _G.Constant.CONST_VITRO then        masterUid = self : getMasterUID()        masterType = self : getMasterType()    end    local selfProperty = _G.g_characterProperty : getOneByUid( masterUid, masterType )    if selfProperty == nil then        return false    end    local skillData = selfProperty : getSkillData()    local skillLv_data = skillData : getSkillLvBySkillID( _skillNode.id )    local skillLv = 1    if skillLv_data ~= nil then        skillLv = skillLv_data : getSkillLevel()    end    local skillMcArg = _G.StageXMLManager : getSkillMcArg( _skillNode.id, skillLv )    for _,character in pairs(characterList) do        local characterType = character : getType()        if character : getLocationX() <= _G.Constant.CONST_BOSS_SECURITY_X and (_G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_BOSS or _G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_CLAN_BOSS) then            CCLOG("在安全区域")        -- elseif _G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_BOSS and characterType ~= _G.Constant.CONST_MONSTER then        --     --如果是BOSS战 对方不是怪物,不赋予攻击        --     print("对方不是怪物")        else            local charProperty = _G.g_characterProperty : getOneByUid( character : getID(), characterType )            if charProperty ~= nil then                CCLOG("charProperty : getTeamID()   "..tostring(charProperty : getTeamID()).."   "..tostring(selfProperty : getTeamID()) )                if not (characterType == _G.Constant.CONST_NPC                                    or characterType == _G.Constant.CONST_TRANSPORT                                    or character == self                                    or (characterType == _G.Constant.CONST_MONSTER and self:getType() == _G.Constant.CONST_MONSTER)  --怪物与怪物之间不能攻击                                    or character:getHP() <= 0                                    or charProperty : getTeamID() == selfProperty : getTeamID() )                    then                    local assailant = self                    local vitroCharacter = nil                    if self : getType() == _G.Constant.CONST_VITRO then                        assailant = _G.CharacterManager : getCharacterByTypeAndID(self : getMasterType(), self : getMasterUID())                        vitroCharacter = self                    end                    _G.SkillHurt : calculateSkillHurt( _skillNode, _currentFrame, assailant, character, skillMcArg, skillLv,vitroCharacter )                    iscollider = true                end--if            end        end    end --for    return iscolliderend--function--显示伤害字体图片function CBaseCharacter.addHurtString( self, _nHp, _nType )    -- local nlength = string.len( tostring(_nHp) )    -- if nlength <= 0 then    --     return    -- end    -- if _G.g_BattleHurtArray == nil then    --     CCSpriteFrameCache :sharedSpriteFrameCache() :addSpriteFramesWithFile("General_battle.plist")    --     _G.g_BattleHurtArray = {}    --     _G.g_BattleHurtCirtArray = {}    --     _G.g_Transparent = CCSpriteBatchNode : create("transparent.png")    --     local tempSprint = CCSprite : createWithSpriteFrameName("battle_word_bj.png")    --     _G.g_battleWordBJ = CCSpriteBatchNode : createWithTexture( tempSprint : getTexture() )    --     for i=0,9 do    --         local tempSprint = CCSprite : createWithSpriteFrameName( "battle_hurt_0"..tostring(i)..".png" )    --         local spriteBatchHurt = CCSpriteBatchNode : createWithTexture( tempSprint : getTexture() )    --         _G.g_BattleHurtArray[i] = spriteBatchHurt    --         tempSprint = CCSprite : createWithSpriteFrameName( "battle_cirt_0"..tostring(i)..".png" )    --         local spriteBatchHurtCirt = CCSpriteBatchNode : createWithTexture( tempSprint : getTexture() )    --         _G.g_BattleHurtCirtArray[i] = spriteBatchHurtCirt    --     end    -- end    -- local _szFirstSprName = _G.g_Transparent : getTexture()    -- local hurtNumArry =  _G.g_BattleHurtArray    -- local nX = 0    -- --if _nType == _G.Constant.CONST_WAR_DISPLAY_NORMAL then    -- if _nType == _G.Constant.CONST_WAR_DISPLAY_CRIT then    --     _szFirstSprName = _G.g_battleWordBJ : getTexture()    --     hurtNumArry = _G.g_BattleHurtCirtArray    --     nX = 10    -- end    -- local _hurtSprite = CCSprite :createWithTexture( _szFirstSprName )    -- self.m_lpHurtStringContainer :addChild( _hurtSprite, 10)    -- local _hurtSpriteSize = _hurtSprite :getContentSize()    -- _hurtSprite :setPosition( ccp( _hurtSpriteSize.width / 2, 100 ) )    -- local stringHp = tostring(_nHp)    -- for i=1, nlength do    --     local currStr = tonumber(string.sub( stringHp, i, i ))    --     for k,v in pairs(hurtNumArry) do    --         print(k,v)    --     end    --     local currStrSprName = hurtNumArry[currStr]    --     local currSprite = CCSprite :createWithTexture( currStrSprName : getTexture() )    --     _hurtSprite :addChild( currSprite )    --     local currSprSize = currSprite :getContentSize()    --     currSprite :setPosition( ccp( -20 + _hurtSpriteSize.width / 2 + 20 * i + nX, 0 ) )    -- end    -- table.insert( self.m_lpHurtStringList, _hurtSprite)    local nlength = string.len( _nHp )    if nlength <= 0 then        return    end    --测试    --_nType = _G.Constant.CONST_WAR_DISPLAY_NORMAL    CCSpriteFrameCache :sharedSpriteFrameCache() :addSpriteFramesWithFile("General_battle.plist")    --根据伤害类型选择图片资源    local _szSprName = "battle_hurt_0"    local _szFirstSprName = "transparent.png"    local nX = 0    if _nType == _G.Constant.CONST_WAR_DISPLAY_NORMAL then        _szSprName      = "battle_hurt_0"        _szFirstSprName = "transparent.png"    elseif _nType == _G.Constant.CONST_WAR_DISPLAY_CRIT then        _szSprName      = "battle_cirt_0"        _szFirstSprName = "battle_word_bj.png"        nX              = 10    end    local _hurtSprite = CSprite :createWithSpriteFrameName( _szFirstSprName )    self.m_lpHurtStringContainer :addChild( _hurtSprite, 10)    local _hurtSpriteSize = _hurtSprite :getPreferredSize()    _hurtSprite :setPosition( ccp( _hurtSpriteSize.width / 2, 200 ) )    local stringHp = _nHp    if _szSprName ~= nil then        for i=1, nlength do            local currStr = string.sub( stringHp, i, i )            local currStrSprName = _szSprName .. tostring( currStr ) .. ".png"            --print("currStrSprName", currStrSprName, currStr)            local currSprite = CSprite :createWithSpriteFrameName( currStrSprName )            _hurtSprite :addChild( currSprite )            local currSprSize = currSprite :getPreferredSize()            currSprite :setPosition( ccp( -20 + _hurtSpriteSize.width / 2 + 20 * i + nX, 0 ) ) --currSprSize.width            --print( "currSprSize.width", currSprSize.width)        end    end    local function delfunc(  )        _hurtSprite : removeFromParentAndCleanup( true )    end    local _angle = math.random(75,105)    local _time = _G.Constant.CONST_WAR_HP_TIME    local _radian = CMath:angleToRadian(_angle)    local _endX = math.cos( _radian ) * _time *math.random(250,280)    local _endY = math.sin( _radian ) * _time *math.random(250,280)    local _callBacks = CCArray:create()    _callBacks : addObject(CCMoveBy:create(_G.Constant.CONST_WAR_HP_TIME, ccp(_endX,_endY)))    _callBacks : addObject(CCFadeOut:create(_G.Constant.CONST_WAR_HP_TIME))    _callBacks : addObject(CCCallFunc:create(delfunc))    _hurtSprite : runAction( CCSequence:create(_callBacks) )endfunction CBaseCharacter.isHaveBuff( self, _buffType )    if self.m_buff[_buffType] ~= nil then        return true    endendfunction CBaseCharacter.Enter( self )    local status = self : getStatus()    self.m_nStatus = -100    self : setStatus( status )    self.m_isFirstEnter = nil    self : addHpSlider()    --    if self.m_PetId ~= nil and self.m_PetId ~= 0 then        local _petId = self.m_PetId        self.m_PetId = 0        self:setPetSkinId( _petId )    end    if self == _G.g_Stage : getPlay() then        self : addBigHpView()    endend--{添加血条}function CBaseCharacter.addHpSlider( self )    if _G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_CITY then        return    end    if self : getType() ~= _G.Constant.CONST_PLAYER and       self : getType() ~= _G.Constant.CONST_PARTNER then       return    end    local back = CCSprite : createWithSpriteFrameName( "battle_mini_hp_back.png" )    local progress = CCSprite : createWithSpriteFrameName( "battle_mini_hp.png" )    local btn = CCSprite : create( "transparent.png" )    -- back : setScaleX( 128 ) --暂时放大    -- progress : setScaleX( 128 ) --暂时放大    self.m_lpHpSlider = CSliderControl:createWithCCSprite( back, progress, btn )    self.m_lpHpSlider : setTouchesEnabled(false)    self.m_lpHpContainer : addChild( self.m_lpHpSlider )    self.m_lpHpSlider : setSliderValue(100)    local locationZ = self : getLocationZ()    self.m_lpHpSlider : setPosition( ccp( 0,locationZ + 250 ) )    self.m_lpHpString = CCLabelTTF : create( tostring(self.m_nHP).."/"..tostring(self.m_nMaxHP), "Marker Felt", 20 )    self.m_lpHpSlider : addChild( self.m_lpHpString )endfunction CBaseCharacter.addBigHpView( self, _hpNum, _isleft )    if _G.g_Stage : getScenesType() == _G.Constant.CONST_MAP_TYPE_CITY then        return    end    local hpNum = 1    local left = true    local sendId = 0    if self : getType() == _G.Constant.CONST_MONSTER then        hpNum = _hpNum or 1        if type(hpNum) ~= "number" then            hpNum = 1        end        hpNum = hpNum <= 0 and 1 or hpNum        left = false        sendId = self :getMonsterXMLID()    else        sendId = self :getID()    end    if _isleft ~= nil then        left = _isleft    end    local container = _G.g_Stage : getUIContainer()    self.m_lpBigHp = CBigHpView( 1,  hpNum,  self : getLv(), left, container, self :getName(), self.m_nHP, self.m_nMaxHP, self.m_nSP, self.m_nMaxSP, sendId, self : getType())    --  注释掉 self.m_lpBigHp = CBigHpView( 1,  hpNum,  self : getLv(), left, container, self :getName(), self.m_nHP, self.m_nMaxHP, self.m_nSP, self.m_nMaxSP)    --print("name,base",self.m_szName)end